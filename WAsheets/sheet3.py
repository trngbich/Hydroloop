# -*- coding: utf-8 -*-
"""
Created on Fri Apr 24 17:10:28 2020

@author: ntr002
"""
import os
import sys
import csv
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import datetime
import calendar
from matplotlib.colors import LinearSegmentedColormap
from dateutil.relativedelta import relativedelta
from . import GIS_functions as gis
from . import calculate_flux as cf
from . import get_dictionaries as gd

def main(BASIN,unit_conversion=1):
    '''
    unit_conversion: 1 for TCM, 1000 for MCM, 1e6 for BCM or km3)
    '''
    #check requirements
    requirements=gd.get_requirements_for_sheet(3)    
    if not cf.check_requirement_sheet(BASIN,requirements):
        sys.exit("ERROR: Data requirements for Sheet 3 are not fulfilled")
    #create folder to save intermetidate data
    folder=os.path.join(BASIN['output_folder'],
                        'csv','timeseries')        
    if not os.path.exists(folder):
        os.makedirs(folder)
    output_file=os.path.join(folder,'sheet3_{0}.csv')
    #create folder to save sheet 3 csv
    sheet_folder=os.path.join(BASIN['output_folder'],'csv','sheet3') 
    if not os.path.exists(folder):
        os.makedirs(sheet_folder) 
        
    #Calulate yearly data to fill in Sheet 3    
        
    #Fill data in Sheet 3 csv
    for i in range(len(ET)):
        year=ET.index[i]
        results=dict()
        results['ET']=np.array(
                (ET.iloc[i].values/unit_conversion))                

        #write sheet 2 csv
        output_fh=os.path.join(sheet_folder,'sheet3_{0}.csv'.format(year))
        create_sheet2_csv(year,results,output_fh)    
        
    return True
        
def create_sheet3_csv(year,results,output_fh):
    """
    Create the csv-file needed to plot sheet 1.
    
    Parameters
    ----------
    results : dict
        Dictionary generated by calc_sheet1.
    output_fh : str
        Filehandle to store the csv-file.
    """
    classes_dict=gd.get_sheet2_classes()  
    lulc_dict=gd.get_lulcs(lulc_version = '4.0')
    first_row = ['LAND_USE', 'CLASS', 'TRANSPIRATION', 'WATER',
                 'SOIL', 'INTERCEPTION', 'AGRICULTURE',
                 'ENVIRONMENT', 'ECONOMY', 'ENERGY', 'LEISURE',
                 'NON_BENEFICIAL']
    
    if not os.path.exists(os.path.split(output_fh)[0]):
        os.makedirs(os.path.split(output_fh)[0])
    
    csv_file = open(output_fh, 'w')
    writer = csv.writer(csv_file, delimiter=';', lineterminator = '\n')
    writer.writerow(first_row)
    
    for LAND_USE in list(classes_dict.keys()):
            for CLASS in list(classes_dict[LAND_USE].keys()):
                print(LAND_USE)
                print(CLASS)
                write_sheet2_row(LAND_USE, CLASS, 
                                 lulc_dict, 
                                 classes_dict,
                                 results,
                                 writer)
    
    csv_file.close()
    
def calc_Y_WP_year(csv_fh, output_dir, croptype):
    """
    Calculate yearly Yields and Water Productivities from seasonal values (created with calc_Y_WP_seasons) and store
    results in a csv-file.
    
    Parameters
    ----------
    csv_fh : str
        csv_file with seasonal values (see calc_Y_WP_seasons)
    output_dir : str
        Folder to store results.
    croptype : str
        Name of the crop for which the Y and WP have been calculated.
        
    Returns
    -------
    csv_filename : str
        Path to the new csv-file.
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)  
        
    start_dates, end_dates, Y, Yirr, Ypr, WP, WPblue, WPgreen, WC, WC_blue, WC_green = read_csv(csv_fh)
    
    years = np.unique(np.array([date.year for date in np.append(start_dates, end_dates)]))
    
    csv_filename = os.path.join(output_dir, r'Yearly_'+ os.path.basename(csv_fh))
    csv_file = open(csv_filename, 'w')
    writer = csv.writer(csv_file, delimiter=';', lineterminator = '\n')
    writer.writerow(["Startdate", "Enddate", "Yield [kg/ha]", "Yield_pr [kg/ha]", "Yield_irr [kg/ha]", "WP [kg/m3]", "WP_blue [kg/m3]", "WP_green [kg/m3]", "WC [km3]", "WC_blue [km3]", "WC_green [km3]"])
    
    for year in years:
        
        starts, ends = (np.array([start_date for start_date, end_date in zip(start_dates, end_dates) if start_date.year == year or end_date.year == year]),
                        np.array([end_date for start_date, end_date in zip(start_dates, end_dates) if start_date.year == year or end_date.year == year]))
    
        boundary = datetime.date(year, 1, 1)
        
        year_length = 366 if calendar.isleap(year) else 365
        
        lengths_total_season = [float(abs((end - start).days)) for start, end in zip(starts, ends)]
        
        lengths_within_year = np.array([min(year_length, abs((boundary - end).days)) - abs(min(0, (boundary - start).days)) for start, end in zip(starts, ends)])
    
        fractions = lengths_within_year / lengths_total_season
        
        y = np.sum(np.array([Y[start_dates == start][0] for start in starts]) * fractions)
        yirr = np.sum(np.array([Yirr[start_dates == start][0] for start in starts]) * fractions)
        ypr = np.sum(np.array([Ypr[start_dates == start][0] for start in starts]) * fractions)
        
        wc = np.sum(np.array([WC[start_dates == start][0] for start in starts]) * fractions)
        wcblue = np.sum(np.array([WC_blue[start_dates == start][0] for start in starts]) * fractions)
        wcgreen = np.sum(np.array([WC_green[start_dates == start][0] for start in starts]) * fractions)
        
        wp = np.average(np.array([WP[start_dates == start][0] for start in starts]), weights = fractions)
        wpblue = np.average(np.array([WPblue[start_dates == start][0] for start in starts]), weights = fractions)
        wpgreen = np.average(np.array([WPgreen[start_dates == start][0] for start in starts]), weights = fractions)
        
        writer.writerow([datetime.date(year,1,1), datetime.date(year,12,31), y, ypr, yirr, wp, wpblue, wpgreen, wc, wcblue, wcgreen])
    
    csv_file.close()
    
    return csv_filename



def calc_Y_WP_seasons(start_dates, end_dates, lu_fh, lu_class, croptype, etgreen_fhs, etgreen_dates, etblue_fhs, etblue_dates, ndm_fhs, ndm_dates, p_fhs, p_dates, output_dir, HIWC_dict, ab = (1.0,1.0)):
    """
    Calculate Yields and WPs per season and save results in a csv-file.
    
    Parameters
    ----------
    start_dates : ndarray
        Array with datetime.date objects specifying the startdates of the growing seasons. See ndvi_profiles.py.
    end_dates : ndarray
        Array with datetime.date objects specifying the enddates of the growing seasons. See ndvi_profiles.py.
    lu_fh : str
        Landuse map.
    lu_class : int
        Landuseclass for which to calculate Y and WP.
    croptype : str
        Name of croptype, should be present in HIWC_dict.keys().
    etgreen_fhs : ndarray
        Array with strings pointing to ETgreen maps.
    etgreen_dates : ndarray
        Array with datetime.date objects corresponding to etgreen_fhs.
    etblue_fhs : ndarray
        Array with strings pointing to ETblue maps.
    etblue_dates : ndarray
        Array with datetime.date objects corresponding to etblue_fhs.
    ndm_fhs : ndarray
        Array with strings pointing to Net-Dry-Matter maps.
    ndm_dates : ndarray
        Array with datetime.date objects corresponding to ndm_fhs.
    p_fhs : ndarray
        Array with strings pointing to P maps.
    p_dates : ndarray
        Array with datetime.date objects corresponding to p_fhs.
    output_dir : str
        Folder to save results
    HIWC_dict : dict
        Dictionary with Harvest indices and Water Contents, see get_dictionaries.get_hi_and_ec().
    ab : tuple, optional
        Two parameters used to split Yield into irrigation and precipitation yield, see split_Yield.
        
    Returns
    -------
    csv_filename : str
        Path to newly created csv-file.        
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)    
    
    csv_filename = os.path.join(output_dir, 'Yields_WPs_{0}_{1}.csv'.format(croptype, int(lu_class)))
    csv_file = open(csv_filename, 'w')
    writer = csv.writer(csv_file, delimiter=';', lineterminator = '\n' )
    
    writer.writerow(["Startdate", "Enddate", "Yield [kg/ha]", "Yield_pr [kg/ha]", "Yield_irr [kg/ha]", "WP [kg/m3]", "WP_blue [kg/m3]", "WP_green [kg/m3]", "WC [km3]", "WC_blue [km3]", "WC_green [km3]"])
    for startdate, enddate in zip(start_dates, end_dates):
        Yield, Yield_pr, Yield_irr, Wp, Wp_blue, Wp_green, Wc, Wc_blue, Wc_green = calc_Y_WP_season(startdate, enddate, lu_fh, lu_class, croptype, etgreen_fhs, etgreen_dates, etblue_fhs, etblue_dates, ndm_fhs, ndm_dates, p_fhs, p_dates, HIWC_dict, ab = ab, output_dir = output_dir)
        
        writer.writerow([startdate, enddate, Yield, Yield_pr, Yield_irr, Wp, Wp_blue, Wp_green, Wc, Wc_blue, Wc_green])
    
    csv_file.close()
    return csv_filename

def calc_Y_WP_season(startdate, enddate, lu_fh, lu_class, croptype, etgreen_fhs, etgreen_dates, etblue_fhs, etblue_dates, ndm_fhs, ndm_dates, p_fhs, p_dates, HIWC_dict, ab = (1.0,1.0), output_dir = None):
    """
    Calculate Yields and WPs for one season.
    
    Parameters
    ----------
    startdate : object
        datetime.date object specifying the startdate of the growing season.
    enddate : ndarray
        datetime.date object specifying the enddate of the growing season.
    lu_fh : str
        Landuse map.
    lu_class : int
        Landuseclass for which to calculate Y and WP.
    croptype : str
        Name of croptype, should be present in HIWC_dict.keys().
    etgreen_fhs : ndarray
        Array with strings pointing to ETgreen maps.
    etgreen_dates : ndarray
        Array with datetime.date objects corresponding to etgreen_fhs.
    etblue_fhs : ndarray
        Array with strings pointing to ETblue maps.
    etblue_dates : ndarray
        Array with datetime.date objects corresponding to etblue_fhs.
    ndm_fhs : ndarray
        Array with strings pointing to Net-Dry-Matter maps.
    ndm_dates : ndarray
        Array with datetime.date objects corresponding to ndm_fhs.
    p_fhs : ndarray
        Array with strings pointing to P maps.
    p_dates : ndarray
        Array with datetime.date objects corresponding to p_fhs.
    output_dir : str
        Folder to save results
    HIWC_dict : dict
        Dictionary with Harvest indices and Water Contents, see get_dictionaries.get_hi_and_ec().
    ab : tuple, optional
        Two parameters used to split Yield into irrigation and precipitation yield, see split_Yield.
        
    Returns
    -------
    Yield : float
        The yield for the croptype.
    Yield_pr : float
        The yield_precip for the croptype.
    Yield_irr : float
        The yield_irri for the croptype.
    Wp : float
        The waterproductivity for the croptype.
    Wp_blue : float
        The blue waterproductivity for the croptype.
    Wp_green : float
        The green waterproductivity for the croptype.
    Wc : float
        The water consumption for the croptype.
    Wc_blue : float
        The blue water consumption for the croptype.
    Wc_green : float
        The green water consumption for the croptype.
    """
    common_dates = becgis.common_dates([etblue_dates, etgreen_dates, p_dates, ndm_dates])
    
    harvest_index = HIWC_dict[croptype][0]  
    moisture_content = HIWC_dict[croptype][1]
    
    current = datetime.date(startdate.year, startdate.month, 1)
    end_month = datetime.date(enddate.year, enddate.month, 1)
    
    req_dates = np.array([current])
    while current < end_month:
        current = current + relativedelta(months = 1)
        req_dates = np.append(req_dates, current)
    
    season_complete = True
    for date in req_dates:
        season_complete = np.all([season_complete, date in common_dates])
        if not season_complete:
            print("{0} missing in input data, skipping this season".format(date))
            
    if season_complete:
    
        fractions = np.ones(np.shape(req_dates))
        
        start_month_length = float(calendar.monthrange(startdate.year, startdate.month)[1])
        end_month_length = float(calendar.monthrange(enddate.year, enddate.month)[1])
        
        fractions[0] = (start_month_length - startdate.day + 1) / start_month_length
        fractions[-1] = (enddate.day -1) / end_month_length
        
        NDMs = np.stack([becgis.open_as_array(ndm_fhs[ndm_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        NDM = np.nansum(NDMs, axis=2)
        del NDMs
        
        ETGREENs = np.stack([becgis.open_as_array(etgreen_fhs[etgreen_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        ETGREEN = np.nansum(ETGREENs, axis=2)
        del ETGREENs
        
        ETBLUEs = np.stack([becgis.open_as_array(etblue_fhs[etblue_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        ETBLUE = np.nansum(ETBLUEs, axis=2)
        del ETBLUEs
        
        Ps = np.stack([becgis.open_as_array(p_fhs[p_dates == date][0], nan_values = True) * fraction for date, fraction in zip(req_dates, fractions)], axis=2)
        P = np.nansum(Ps, axis=2)
        del Ps
        
        LULC = becgis.open_as_array(lu_fh)
        
        NDM[NDM == 0] = np.nan
        NDM[LULC != lu_class] = ETBLUE[LULC != lu_class] = ETGREEN[LULC != lu_class] =  np.nan
        
        Y = (harvest_index * NDM) / (1 - moisture_content)
        
        etbfraction = ETBLUE / (ETBLUE + ETGREEN)
        pfraction = P / np.nanmax(P)
        fraction = split_Yield(pfraction, etbfraction, ab[0], ab[1])
        
        Yirr = Y * fraction
        Ypr = Y - Yirr

        if output_dir:
            x = y = np.arange(0.0, 1.1, 0.1)
            XX, YY = np.meshgrid(x, y)
            Z = split_Yield(XX,YY, ab[0], ab[1])
            plt.figure(1, figsize = (12,10))
            plt.clf()
            cmap = LinearSegmentedColormap.from_list('mycmap', ['#6bb8cc','#a3db76','#d98d8e'])
            plt.contourf(XX,YY,Z,np.arange(0.0,1.1,0.1), cmap = cmap)
            plt.colorbar(ticks = np.arange(0.0,1.1,0.1), label= 'Yirr as fraction of total Y [-]', boundaries = [0,1])
            plt.xlabel('Normalized Precipitation [-]')
            plt.ylabel('ETblue/ET [-]')
            plt.title('Split Yield into Yirr and Ypr')
            plt.suptitle('Z(X,Y) = -(((Y-1) * a)^2 - ((X-1) * b)^2) + 0.5 with a = {0:.2f} and b = {1:.2f}'.format(ab[0],ab[1]))
            plt.scatter(pfraction, etbfraction, color = 'w', label = croptype, edgecolors = 'k')
            plt.legend()
            plt.xlim((0,1))
            plt.ylim((0,1))
            plt.savefig(os.path.join(output_dir, '{0}_{1}_{2}_cloud.png'.format(croptype, req_dates[0], req_dates[-1])))

        Yield = np.nanmean(Y)
        Yield_pr = np.nanmean(Ypr)
        Yield_irr = np.nanmean(Yirr)
        
        Et_blue = np.nanmean(ETBLUE)
        Et_green = np.nanmean(ETGREEN)
        
        areas = becgis.map_pixel_area_km(lu_fh)
        Wc_blue = np.nansum(ETBLUE / 1000**2 * areas)
        Wc_green = np.nansum(ETGREEN / 1000**2 * areas)
        Wc = Wc_blue + Wc_green
        
        areas[LULC != lu_class] = np.nan
        print('{0}: {1} km2'.format(croptype, np.nansum(areas)))
        
        Wp = Yield / ((Et_blue + Et_green) * 10)
        Wp_blue = np.where(Et_blue == 0, [np.nan], [Yield_irr / (Et_blue * 10)])[0]
        Wp_green = np.where(Et_green == 0, [np.nan], [Yield_pr / (Et_green * 10)])[0]
        
    else:
        
        Yield = Yield_pr = Yield_irr = Wp = Wp_blue = Wp_green = Wc = Wc_blue = Wc_green = np.nan
        
    return Yield, Yield_pr, Yield_irr, Wp, Wp_blue, Wp_green, Wc, Wc_blue, Wc_green

def import_growing_seasons(csv_fh):
    """
    Reads an csv file with dates, see example for format of the csv file.
    
    Parameters
    ----------
    csv_fh : str
        Filehandle pointing to csv-file
        
    Returns
    -------
    start_dates : ndarray
        List with datetime.date objects
    end_dates : ndarray
        List with datetime.date object
    
    Examples
    --------
    The csv file should be like:
    >>> Start;End<new_line> 
            04/11/2000;17/02/2001<new_line>
            03/05/2001;02/07/2001<new_line>
            29/11/2001;27/02/2002<new_line>
            etc.
    
    """
    start_dates = np.array([])
    end_dates = np.array([])

    with open(csv_fh) as csvfile:
         reader = csv.reader(csvfile, delimiter=';')
         for row in reader:
             if np.all([row[0] != 'Start', row[1] != 'End']):
                 start_dates = np.append(start_dates, datetime.datetime.strptime(row[0], '%d/%m/%Y').date())
                 end_dates = np.append(end_dates, datetime.datetime.strptime(row[1], '%d/%m/%Y').date())
    
    return start_dates, end_dates

def read_csv(csv_fh):
    """
    Reads and csv file generated by the function calc_Y_WP_seasons and returns the 
    values as np.arrays.
    
    Parameters
    ----------
    csv_fh : str
        Filehandle pointing to a csv-file generated by calc_Y_WP_seasons.
        
    Returns
    -------
    start_dates : ndarray
        Array containing datetime.date objects.
    end_dates : ndarray
        Array containing datetime.date objects.      
    Y : ndarray
        Array containing Yield data.
    Yirr : ndarray
        Array containing Yield from irrigation data.
    Ypr : ndarray
        Array containing Yield from precipitation data.
    WP : ndarray
        Array containing Water Productivity data.
    WPblue : ndarray
        Array containing Blue WP data.
    WPgreen : ndarray
        Array containing Green WP data.
    """
    start_dates = np.array([])
    end_dates = np.array([])
    Y = np.array([])
    Yirr = np.array([])
    Ypr = np.array([])
    WP = np.array([])
    WPblue = np.array([])
    WPgreen = np.array([])
    WC = np.array([])
    WC_green = np.array([])
    WC_blue = np.array([])
    
    with open(csv_fh) as csvfile:
         reader = csv.reader(csvfile, delimiter=';')
         for row in reader:
             if np.all([row[2] != 'nan', row[0] != 'Startdate']):
                 try:
                     start_dates = np.append(start_dates, datetime.datetime.strptime(row[0], '%Y-%m-%d').date())
                     end_dates = np.append(end_dates, datetime.datetime.strptime(row[1], '%Y-%m-%d').date())
                 except:
                     start_dates = np.append(start_dates, datetime.datetime.strptime(row[0], '%d/%m/%Y').date())
                     end_dates = np.append(end_dates, datetime.datetime.strptime(row[1], '%d/%m/%Y').date())                     
                 Y = np.append(Y, float(row[2]))
                 Ypr = np.append(Ypr, float(row[3]))
                 Yirr = np.append(Yirr, float(row[4]))
                 WP = np.append(WP, float(row[5]))
                 WPblue = np.append(WPblue, float(row[6]))
                 WPgreen = np.append(WPgreen, float(row[7]))
                 WC = np.append(WC, float(row[8]))
                 WC_blue = np.append(WC_blue, float(row[9]))
                 WC_green = np.append(WC_green, float(row[10]))
                 

    return start_dates, end_dates, Y, Yirr, Ypr, WP, WPblue, WPgreen, WC, WC_blue, WC_green

def split_Yield(pfraction, etbfraction, a, b):
    """
    Calculate fractions to split Yield into Yield_precip and Yield _irri.
    
    Parameters
    ----------
    pfraction : ndarray
        Array of Precipitation devided by np.nanmax(P)
    etbfraction : ndarray
        Array of fraction of ETblue of total ET.
    a : float
        Parameter to define the fraction.
    b : float
        Parameter to define the fraction.
        
    Returns
    -------
    fraction : ndarray
        Array of the fraction.
    """
    fraction = -(((etbfraction-1)*a)**2 - ((pfraction-1)*b)**2) + 0.5
    fraction = np.where(fraction > 1.0, 1.0, fraction)
    fraction = np.where(fraction < 0.0, 0.0, fraction)
    return fraction

def plot_Y_WP(csv_fh, output_dir, croptype = None, catchment_name = None, filetype = 'png'):
    """
    Plot yields and water productivities per season or per year.
    
    Parameters
    ----------
    csv_fh : str
        csv-file with yields and wps per season or year, can be generated with calc_Y_WP_year or with calc_Y_WP_seasons.
    output_dir : str
        folder to save graphs.
    croptype : str, optional
        String used to format the graphs.
    catchment_name : str, optional
        String used to format the graphs.
    filetype : str, optional
        filetype, default is pdf, can also choose, 'png'.    
    """

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
            
    start_dates, end_dates, Y, Yirr, Ypr, WP, WPblue, WPgreen, WC, WCblue, WCgreen = read_csv(csv_fh)
    
    ordinal_startdates = np.array([date.toordinal() for date in start_dates])
    ordinal_enddates = np.array([date.toordinal() for date in end_dates])
    
    fig = plt.figure(1, figsize = (10,10))
    plt.clf()
    plt.grid(b=True, which='Major', color='0.65',linestyle='--', zorder = 0)
    ax = fig.add_subplot(111)
    ax.bar(start_dates, Yirr, ordinal_enddates-ordinal_startdates, color = '#6bb8cc', label = 'Yield from irrigation', linewidth = 2, edgecolor = 'w', align='edge')
    ax.bar(start_dates, Ypr, ordinal_enddates-ordinal_startdates, bottom = Yirr, color = '#a3db76', label = 'Yield from precipitation', linewidth = 2, edgecolor = 'w', align='edge')
    ax.set_title('Seasonal Yield, {0} in {1}'.format(croptype, catchment_name))
    ax.set_xlabel('Time')
    ax.set_ylabel('Yield [kg/ha]')
    [r.set_zorder(10) for r in ax.spines.values()]
    fig.autofmt_xdate()
    ax.legend(loc = 'upper left',fancybox=True, shadow=True)
    ax.set_ylim([0, np.max(Y) * 1.2])
    plt.savefig(os.path.join(output_dir,'{0}_yields.{1}'.format(croptype,filetype)))
    
    ordinal_meandates = np.mean([ordinal_startdates, ordinal_enddates], axis=0)

    fig = plt.figure(2, figsize = (10,10))
    plt.clf()
    plt.grid(b=True, which='Major', color='0.65',linestyle='--', zorder = 0)
    ax = fig.add_subplot(111)
    red_patch = mpatches.Patch(color='#d98d8e', label='WP')
    blue_line = mlines.Line2D([], [], color='#6bb8cc', label='WPblue', lw = 3)
    green_line = mlines.Line2D([], [], color='#a3db76', label='WPgreen', lw = 3)
    ax.legend(handles=[red_patch,blue_line, green_line],loc = 'upper left',fancybox=True, shadow=True)
    ax.bar(ordinal_meandates, WPblue, color = 'w', linewidth = 2, edgecolor = 'w', xerr = (ordinal_enddates-ordinal_startdates)/2.2, ecolor = '#6bb8cc', capsize = 0, error_kw = {'lw': 3})
    ax.bar(ordinal_meandates, WPgreen, color = 'w', linewidth = 2, edgecolor = 'w', xerr = (ordinal_enddates-ordinal_startdates)/2.2, ecolor = '#a3db76', capsize = 0, error_kw = {'lw': 3})
    ax.bar(start_dates, WP, ordinal_enddates-ordinal_startdates, color = '#d98d8e', label = 'WP', linewidth=2, edgecolor='w', align='edge')
    ax.set_title('Seasonal Water Productivity, {0} in {1}'.format(croptype, catchment_name))
    ax.set_ylabel('Water Productivity [kg/m3]')
    ax.set_xlabel('Time')
    ax.set_ylim([0, max(max(WP), max(WPblue), max(WPgreen)) *1.2])
    fig.autofmt_xdate()
    [r.set_zorder(10) for r in ax.spines.values()]
    plt.savefig(os.path.join(output_dir,'{0}_wps.{1}'.format(croptype,filetype))) 